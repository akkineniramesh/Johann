
Untyped lambda-calculus with ambiguity-as-join. (SKJ) \label{sec:skj}

  Comment: Overview: 
    * #bool,semi# for logic
    * #sgtn,pair,Tuple# for convenience
    * #Maybe,Sum,Prod# for type constructions
    * #semiset# for concurrency
    * #nat,zero,succ# for counting
    * #enum,idx# for enumeration
    * #code,eval,quote# for working with the meta-theory

  This chapter introduces an untyped lambda-calculus
  with a binary semilattice operation,
  the join with respect to Scott's information ordering.
  We call this system SKJ, as it is the fragment of Scott's Dinfty model
  generated by #S#, #K#, and binary join.
  lambda-calculus with join has long been studied as a model for
  concurrency / parallelism and ambiguity / multiplicity;
  nondeterminism also satisfies the semilattice axioms,
  but is better modelled by meet (Dezani02).

  The main discovery of this thesis is that, under the theory H*,
  that there is an interpretation of typed lambda-calculus SK into
  untyped lambda-join-calculus SKJ,
  where types are interpreted as closure operations
  (SKJ-terms #a# satisfying #I[=a=a*a#).
  Specifically we show in \ref{sec:skj/simple} the following:
  Thm: Let #tau# be a simple type (with any number of free type variables).
    Then there is an SKJ-definable closure #[tau]#
    whose fixedpoints are exactly the terms of type #tau#.
    Moreover, the interpretation #[-]# is effective.
  For example, the boolean type #[a->a->a]# has five inhabitants
  #{_, \x,y.x, \x,y.y, \x,y.(x|y), T}#.
  Dana Scott proved a similar definability theorem in Scott76,
  showing that simple types are definable using step functions.
  The advantage of our approach is economy of language:
  we achieve the same rich type theory using only a finitely generated magma.
  Cardelli in Cardelli86 observes that Scott's types-as-closures
  models omega-order polymorphism and dependent types,
  although the Curry-Howard corresponding logic is inconsistent.
  These results do not depend on step functions, and hence also apply to SKJ.

  One already well-known motivation for adding a join operation is
  to achieve a more robust notion of recursively enumerable set,
  as discussed by Constable and Smith Constable88.
  It is a basic theorem of computability theory that the
  recursively enumerable sets are exactly the recursively semidecidable sets,
  and that these sets are closed under intersection and union.
  More generally the equivalence and intersection theorem results
  extend from SK to arbitrary extensions of SK;
  however the proof of closure under union may fail in some extensions.
  Footnote: The proof exploits details of beta reduction to dovetail
    two computations in a virtual machine;
    general extensions may not allow the definition of such a virtual machine.
  The join operation can be seen as an internalization of the
  closure-under-unions theorem,
  allowing a proof of closure that generalizes to arbitrary extensions.

  Another motivation for join comes from type theory.
  Under the Curry-Howard correspondence,
  the join operation does not prove any new theorems,
  but allows us to add ambiguity to existing proofs.
  The human proof idiom most closely corresponding to join
  is probably the _without-loss-of-generality_ construct.
  But ambiguity and types-as-closures also allows for a much more powerful
  proof technique, a sort of _semantic_type_inference_ that allows us
  to raise untyped proof sketches up to complete well-typed proofs
  using the theorem-as-closure-operator they are intended to prove.
  We illustrate the WLOG construct here,
  but delay discussion of semantic type inference until we
  build up some dependent type theory in \ref{sec:skj/terms}.
  Then in \ref{sec:examples} we present two case studies makeing extensive
  use of proof sketching and type inference.

  To see how the WLOG construct works in SKJ, let us consider a simple theorem.
  Thm: In a list of three booleans (with values #K,F#),
    at least two items are the same.
  A purely sequential proof must case-analyze each item.
  Pf: Let #(x,y,z)# be given.
    Case: if #x=K#,
      Subcase: if #y=K# then x=y.
      Subcase: if #y=F#
        Subsubcase: if #z=K# then #x=z#.
        Subsubcase: if #z=F# then #y=z#.
    Case: if #x=F#,
      Subcase: if #y=K#
        Subsubcase: if #z=F# then #x=z#.
        Subsubcase: if #z=K# then #y=z#.
      Subcase: if #y=F# then x=y.
    []
  Since the two cases #x=K# and #x=F# are symmetric under a #K<-->F# reversal,
  we can simplify the proof to
  Pf: Let #(x,y,z)# be given.
    Note that the theorem is symmetric under #K<-->F# reversal.
    Thus assume WLOG that #x=K#.
    Case: if #y=K# then x=y.
    Case: if #y=F#
      Subcase: if #z=K# then #x=z#.
      Subcase: if #z=F# then #y=z#.
    []
  Now consider a Curry-Howard corresponding type.
  ###[
    thm := /\x:bool,y:bool,z:bool.
                Sum (iff x y unit nil).   #an equality dependent type
                Sum (iff y z unit nil).
                     iff x z unit nil
  ###]
  A purely sequential inhabitant is
  ###[
    pf := \x:bool,y:bool,z:bool.
              x ( y (inl <>)
                    ( z (inr(inr <>))
                        (inr(inl <>)) ) )
                ( y ( z (inr(inl <>))
                        (inr(inr <>)) )
                    (inl <>) )
  ###]
  but a simpler proof could use a join operation.
  ###[
    pf' := (I | \p,x,y,z. p(not x)(not y)(not z))     #express symmetry
              \x:bool,y:bool,z:bool.
                x ( y (inl <>)                        #WLOG #x=K#
                      ( z (inr(inr <>))
                          (inr(inl <>)) ) )
                  _                                   #ignore other cases
  ###]

  Takeout: 
    The Karoubi envelope of a CCC is the category with obejects idempotents and
    morphisms functions fixed by pre-and post-composition by the domain and
    range, resp.
    As observed in Scott76 and Cardelli86,
    restricting to closures (increasing idempotents) yields a rich type theory
    (but the Curry-Howard corresponding logic is inconsistent).
    
    The myriad types-as-closures in Dinfty are neither SK- nor SKJ-definable
    However most of the useful closures reflect down from Dinfty to its
    definable fragment, in the sense that, eg,
    there is a Dinfty closure #_bool# mapping Dinfty to the lattice #{_,K,F,T}#.
    Reflecting down, there is an SKJ-definable #bool# mapping
    _the_SKJ-definable_ terms to the same #{_,K,F,T}#,
    but failing for general Dinfty terms.
    Footnote: the problem is step-functions;
      #bool# behaves well on all Bohm-trees.

    LATER others?

  Comment: TODO maybe factor in axiom stuff to SK/SKJ/SKR/SKRJ/SKJO ?

  ###r ../axioms/join ../axioms/idem ../axioms/close ../axioms/power
  ###r ../axioms/div simple
  ###r types ../axioms/types
  ###r logic tests ../axioms/tests
  ###r nats numerals terms
  ####r enum
  ####r nats2
  ####r tuples streams dialogs strings lists coding
  ####r categories coalgebras algebras
  ####r sets
  ####r reals calculus

