
A constructor for simple types of fuzzy terms. \label{sec:skrj/simple}
  ###<
    !import axioms/close axioms/power axioms/random.
  ###>

  This section describes our attempt to define closures for simple types in
  SKRJ.
  At the time of writing of this thesis, we have not succeeded in defining
  a #Simple# type constructor.
  Later sections in this chapter rely on a #Simple# type constructor,
  and serve to motivate what can be done if #Simple# is indeed definable.

  The main difficulty in extending our definition of #Simple# from
  \ref{sec:skj/simple} is that we cannot raise different branches of Bohm trees
  with different section-retract pairs; ie, the coherence lemma fails.
  This same difficulty prevents us from disambiguating terms in
  \ref{sec:skjo/types}.

  Interpreting simple types as closures. 

    We now state the simple types conjecture for SKRJ,
    following the simple types theorem from SKJ.
    The languages of terms and types in \ref{fig:skrj-simple}
    differ from the SKJ terms and types only in that we now have mixtures.
    Figure: 
      ###g p r s t
      ###-
        #term formation
        ----   ----   ----
        S tm   K tm   T tm

        m tm   n tm   /\m in _M. m tm   /\m in supp _M. m tm
        -----------   ---------------   --------------------
           m n tm       Join _M tm           EE[_M] tm

        #type formation

            a var      G|-s tp   G|-t tp
        ------------   -----------------   ---------
        G,a,G'|-a tp       G|-s->t tp      G|-any tp

        #typing

        G|-r tp   G|-s tp   G|-t tp   G|-s tp   G|-t tp   G|-t tp
        ---------------------------   -----------------   -------
        S::(r->s->t)->(r->s)->r->t        K::s->t->s       T::t

        m::s->t   n:s   /\m in _M. m::t   /\m in supp _M. m::t    m tm
        -------------   ---------------   --------------------   ------
           m n::t         Join _M::t           EE[_M]::t         m::any
      ###-
      Caption: \label{fig:skrj-simple}
        Typing and type interpretation.
        #EE[_M]# denotes expectation or integration over a probability
        distribution #_M# with support #_M#.
        #Join _M# denotes the join or convex hull generated by
        a set #_M# of SKRJ-terms-as-CSPDs.
      ###u p r s t
    Conjecture: There is an SKRJ-definable term #Simple# and corresponding
      interpretation #[-]# of simple types, following \ref{sec:skj/simple},
      such that for each term #q# and simple type #tau#
      as in Figure \ref{fig:skrj-simple},
      #q::tau# iff #q:[tau]#.

    Our current best attempt is similar to the #Simple# from SKJ.
    We first define two section-retract pairs
    ###<
        raise := (\x,-. x).
        lower := (\x. x T).
        !check raise*lower = I.
        !check lower*raise ![= I.

        join := (\f,x,y. f (x|y)).
        copy := (\f,x. f x x).
        !check join*copy = I.
        !check copy*join ![= I.
    ###>
    and then recursively close under conjugation.
    ###[
        Simple := (any->V) (
            Y\s,f. f I I
                 | f raise lower
                 | f join copy
                 | s\a,a'. s\b,b'. f (a'->b) (a->b')
        ).
    ###]

    Note that we need section-retract pairs
    to distribute over CSPDs of head normal forms.
    Each of #raise#, #lower#, #join#, #copy# and their conjugates do,
    however, this requirement prevents us from using pairs like
    ###[
      open := (\f,<x>. f x).
      pack := (\f,x. f<x>).

      curry := (\f,x,y. f(x,y)).
      uncurry := (\g,(x,y). g x y).
    ###]

Comment: OLD ----------------------------------------------------------------- 

  Types, Terms and Typing rules. 

    We begin with languages of terms and types, and rules for typing terms.
    We also choose to deal with types and terms in infinitary form:
    we join over infinite sets,
    create probability distributions over infinite probability mass functions
    (always on countable sets),
    and later intersect infinite sets of types.
    TODO add recursive, dependent, and polymorphic types
    ###g a b G
    ###s a1 a2 an
    ###-
      #type formation (tp-): #type tp

                        a var   a tp   b tp   /\a in A. a tp
      ------   ------   -----   -----------   --------------
      any tp   nil tp    a tp     a->b tp        Insn A tp

      #term formation (tm-): #term tm

      v var   m tm   n tm   x var   m tm          /\m in M. m tm   p Prob(tm)
      -----   -----------   ------------   ----   --------------   ----------
      v tm       m n tm        \x.m tm     T tm     Join M tm       EE p tm
      
      #typing (tt-): #context|-term::type

      G,x::a|-M::b    G|-f::a->b   G|-x::a
      -------------   --------------------   --------
      G|-\x.M::a->b        G|-f x::b         |-x::any

       a tp    a tp   b tp   G|-m::a   G|-n::a   /\M in _M. G|-M::a
      ------   -----------   -----------------   ------------------
      |-T::a   |-_::a->b          G|-m|n:a          G|-Join _M::a

      G|-m::a   G|-n::a
      -----------------
           G|-m+n:a
    ###-
    where type intersections are restricted to being nonempty.
    Notice that the function type is covariant in _both_ arguments.
    Def: We also define simple terms
      * nullary join #_ := Join {}#,
      * binary join #J := \x,y. Join{x,y}#, and
      * random bit #R := \x,y. Rand{ x@1/2, y@1/2 }#.
    Comment: 
      Question: how does randomness connect to the type system?

  Interpreting types as closures. 

    We need a few weak section-retract pairs
    ###<
      raise := (\x,-. x).
      lower := (\x. x T).
      !check raise*lower = I.
      !check lower*raise ![= I.

      open := (\f,<x>. f x).        #WARNING this is non-affine in f
      pack := (\f,x. f<x>).
      !check open*pack = I.
      !check pack*open ![= I.

      curry := (\f,x,y. f(x,y)).
      uncurry := (\g,(x,y). g x y). #WARNING this is non-affine in g
      !check curry*uncurry = I.
      !check uncurry*curry ![= I.

      join := (\f,x,y. f (x|y)).
      copy := (\f,x. f x x).
      !check join*copy = I.
      !check copy*join ![= I.
    ###>
    Joining these gives the type interpreter for a single atomic type
    ###<
      Simple := (any->V) (
        (I,I) | (raise,lower)
              | (open,pack)
              | (curry,uncurry)
              | (join,copy)
      ).
    ###>

  Inhabitants in SKRJ. 

    TODO adapt theorems from SKJ's proof
    * use the affine lemma
    * use raising lemmas

    Lem: In SKRJ #inhab(a->a)={ _@p + I@q + T@r | p+q+r=1}#.
    Pf: LATER

  OLD ------------------------------------------------------------------------

  Types under randomness. 

    Def: A term #M# is _(immediately)_affine_ if it is a join of mixtures of
      terms of forms
      ###[
        \x,_y. x _M
      ###]
      for various #_y,_M#, and #x# is not free in any of the #_M#.
    In the following, let #a# be an SKJ-definable closure.
    Lem: (Lifting) If #a# is affine, then #a# acts pointwise on mixtures.
    Lem: (Mixing) If #a# is affine,
      and simultaneously raises every finite set #Q# of pure candidates,
      then #a# raises mixtures.

  OLD ---- moved from skrj/types

  ###g a b c t
  Main Theorem: (semi) A closure #semi# is SKRJ-definable
    with inhabitants #inhab(semi) = {_@a+I@b+T@c | (a,b,c) in S_2}#
    (where #S_2# is the 2-simplex).
  Pf: First note that #_,I,T:semi#.
    Next consider a (JR-)Bohm tree #\_x. h _M#.
    Each term #_M# is a slurry of BTs,
    indeed the limit of finite slurries of finite BTs.
    Note that transforms of the shape #\q,_y. q _N# (where q not free in #_N#)
    distribute over slurries.
    By following lemma, for any finite slurry of finite BTs,
    there is a sequence #_tau# of transforms
    that _simultaneously_raises_ each BT to a slurry of only #_,I,T#.
    Finally, by following lemma, any slurry of #_,I,T# is equivalent to just a
    mixture of #_,I,T#.
    XXX (can this be assumed to be a mixture?)
    []
  Lem: (simultaneous raising) We construct a finite set #{t_1,...,t_n}=:TT#
    of transforms such that for any finite set of finite BTs #{B_1,...,B_k}#,
    there is a finite sequence #_t# of transforms from #TT# "raising" each
    #B_i#, i.e., #B_i [= _t B_i =# a slurry of #_,I,T#.
  Pf: ??? LATER
  ###u t
  Lem: Any slurry of #_,I,T# is equivalent to a mixture of #_,I,T#. XXX fails
  Pf: It suffices to show #I|_+T = I+T#. XXX why?
    Thus consider any trace t.
    ###[
      c(I _M) = c(_M)
      c((_+T) _M) = 1/2
      c((I+T) _M) = [c(_M) + 1] / 2
    ###]
  ###u a b c G

  Thus we have
  ###<
    semi := V (???).
  ###>

  More uniformly in type-code, ... LATER



