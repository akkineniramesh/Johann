

Batch unfailing completion for search problems. 
  \label{sec:algorithms/completion}

  Questions: 
    * How to formalize refutation/inequality?
    * How to treat holes: variables or ?'s ?
    * How to do pattern matching in general?

  This section describes an unfailing completion procedure directed by a set
  of search-problems.
  Each search problem has the rough form
  Problem: Fill in holes.
    Find: all completions of the definitions-with-holes #x_1:=D_1,...,x_n:=D_n#
    Satisfying: a given set of equations #M_1=N_1,...,M_k=N_k#
    Assuming: a set of hypothetical equations
    (note that proofs are not retained)
  We formalize this proceedure as a set of inference rules or operations on a
  machine state #E/R/P/S# defined below.
  Our rules extend pure unfailing completion (Bachmair89) by including
  branching and pruning for search,
  simplification for problems and solutions, and factoring for problems.
  #XXX we may also add a rule for equation branching.

  Plaisted93, ??? survey rewriting techniques.
  Bachmair89 devlops unfailing completion and an extension to Horn clauses.
  and
  Dershowitz85 and Dershowitz93 apply completion to program synthesis.
  The Waldmeister system (Buch96) is an example implementation of unfailing
  completion for equational theorem proving.
  Avenhaus93 describes a distributed implementation where multiple provers
  work concurrently on a single problem.

  Terms, Equations, Problems and States. 

    _Terms_ are generated by
    ###[
      T ::= a for a in A  #atoms
          | v for v in V  #variables
          | T T           #applications
          | ?             #holes
    ###]
    a term is _ground_ if it has no variables and _complete_ if it has no holes.
    We often use lambda-calculus and other syntactic sugar, but this is always
    to be understood as shorthand for combinators.
    Complete definitions for all sugar are given in section
    \ref{sec:algorithms/translation}.

    Substitutions on terms are written posfix as #s sigma#.
    Contexts are written as #C[ ]#, and #C[s]# is some context of #s#.
    We also write #I[s]=C[s sigma]# for a context-substitution instance of #s#.
    A context-substitution is _proper_, written #I[s]|>s# in the encompassment
    ordering iff #s# is not a context-substitution of #I[s]#.

    Given a norm #|-|# on terms, and an arbitrary ordering on atoms,
    we define the length-then-lex ordering # < # by
    ###-
      |M| < |N|       |a|=|b|   a < b in A       |a|=|M M'|
      --------- len   -------------------- arb   ---------- lex-atom
        M < N                a < b                a < M M'

      |M M'|=|N N'|   M < N           |M M'|=|M N'|   M' < N'
      --------------------- lex-lhs   ----------------------- lex-rhs
            M M' < N N'                       M M' < M N'
    ###-

    _Equations_ are undirected _unordered_ pairs #M=N# of terms.
    We treat equality as syntactically symmetric so #M=N# and #N=M# denote the
    same equation (here we differ from many authors).
    The set of _orientable_instances_ of a set of equations is defined as
    #R_E:={I[s]->I[t]|s=t in E, s > t}#.

    _Reductions_ are pairs #M->N# where always #M > N# it is true that #M=N#
    (see the soundness theorem below).
    A set #R# of reductions is _orthogonal_ iff
    * no right-hand side in #R# is reducible WRT #R#, and
    * no left-hand side in #R# is match by more than one rule in #R#.
    Fixing a set #R#, we write #-># for one-step reductions and #->># for the
    transitive reflexive colsure of #->#.
    A reduction relation is _Church-Rosser_ (CR) iff for any #s,t,u#, if
    #s<-u->t# then for some #v#, #s->>v<<-t#.
    Thus CR follows from the existenc of a confluence #v# of every such
    _critical_pair_ #(s,t)#.
    Given a reduction relation #R# and set of equations #E#,
    define the set of critical pairs #CP(E,R):={(s,t)|s<-u->t in R+R_E}#.

    _Problems_ look like
    ###[
      l : (x1:=M1,...,xn:=Mn, H1,...,Hh |- C1,...,Cc)
    ###]
    where #l# is a label,
    the #Mi# may have holes,
    #Hi# and #Ci# are equations,
    and the entire statement has no free variables.
    The motivation is to find complete definitions of the #xi# satisfying the
    entailment #_H|-_C# (i.e. under all hypotheses, _all_ conclusions are true).
    XXX change this to coherent logic XXX
    In pure search problems, there are no hypotheses #Hi#, e.g.
    ###[
      #assume #nat,succ,zero# have been defined
      find_pred:
          #find a definition for the predecessor function
          pred := nat->nat ??? |- pred.
    ###]
    In pure theorem-proving problems, there are no holes in the #Mi#, e.g.
    ###[
      mul_assoc:
          #prove associativity of multiplication
          mul := Sym_bin_op nat (\x,y. x y).
          |- (\x,y,z. mul x. mul y z) = (\x,y,z. mul (mul x y) z).
    ###]
    In pure enumeration problems, there are no conclusions #Ci#, e.g.
    ###[
      inhab_bool:
          #find all inhabitants of bool
          x := bool ???. |-.
    ###]

    A state is a 4-tuple #E/R/P/S# of sets (braces elided), where
    ###[
      E = phi,...                 #true coherent formulae
      R = s->t,...                #true oriented reducions
      P = l:(_x:=_M. _H|-_C),...  #labelled problems
      S = l:(_x=_M),...           #solutions to problems
    ###]
    We start at a state #E//P/#, where
    #E# is described in \ref{sec:axioms},
    #P# is a user-specified set of problems,
    and there are no reductions or solutions.

    Coherent logic and a proof search for coherent theories are described in
    Bezem and Coquand (Bezem05) describe coherent logic and an proof search
    procedure in coherent theories in Bezem05.
    Bezem and Hendriks describe an extended example in Bezem07.
    Some examples of coherent rules are
    ###-
      ----------------   -------  -----
      S x y z=x z(y z)   K x y=x  I x=x

      -------   ---------------   -----   -------   ---------
      x|y=y|x   (x|y)|z=x|(y|z)   x|x=x   x|Bot=x   x|Top=Top

                   y=S I y
      ----------   -------
      Y f=f(Y f)     y=Y

                      I[=a   a=]a|a   a x[=x
      -------------   -------------   -------
      V a=I|a*(V a)       V a=a       V a x=x

          x:div                x:bool
      -------------   -------------------------
      x=Top   x=Bot   x=Bot   x=Top   x=K   x=F

       a:V    b:V    x:Prod a b
      --------------------------
      x=Top   \/u:a,v:b. x=(u,v)

                 a:V    b:V    x:Sum a b
      -----------------------------------------------
      x=Bot   x=Top   \/u:a. x=inl u   \/v:b. x=inr v

          x:nat            x:nat   x I[=I
      --------------   ------------------------
      x=Top   x I[=I   x=Bot   \/x':nat. x'I[=I
    ###-
    where we use the shorthand #x|y=J x y#, #x[=y<==>x|y=y#, and #x:a<==>x=a x#.

  State transitions. 

    The purpose of completion is to convert a set of equations to an oriented
    set of reductions, so that equality checking is easy: reduce two terms; if
    they have the same normal form they are equal.
    Our equational theory of interest is not finitely axiomatizable (in fact
    $\Pi^0_2$-complete), and even our approximate finite axiomatization is only
    semi-deicidable.
    Thus our set of reductions will be infinite.

    Note: I'm trying a nonstandard definition with an additional branch-E rule
      working with orient to replace the orientable subset #R_E#.
    The inference rules for batch unfailing completion are now
    Figure: Inference rule for batch unfailing completion
      ###l perp
      ###-
        ##E-R# interaction

        E,s=t/R/P/S   s > t
        ------------------- orient
            E/R,s->t/P/S
        
          E/R,s->t,s->u/P/S
        --------------------- deduce-naive
        E,u=t/R,s->t,s->u/P/S
        
        E/R/P/S   (s,t) in CP(E,R)
        -------------------------- deduce-unfailing
               E,s=t/R/P/S

        ##E-R# simplification

        E,s=s/R/P/S
        ----------- prune-E
          E/R/P/S

        E,s=t/R,t->u/P/S
        ---------------- simp-E
        E,s=u/R,t->u/P/S

        E/R,s->I[t],t->u/P/S
        -------------------- simp-R-right-R
        E/R,s->I[u],t->u/P/S

        E/R,I[s]->u,s->t/P/S   I[s]|>s
        ------------------------------ simp-R-left-R
             E/R,I[t]->u,s->t/P/S

        ##E->R# influence, version 1

        E,s=t,I[s]=I[t]/R/P/S   I[s]|>s
        ------------------------------- subsume-E
                 E,s=t/R/P/S

        E,t=u/R,s->I[t]/P/S   t > u
        --------------------------- simp-R-right-E
            E,t=u/R,s->I[u]/P/S

        E,s=t/R,I[s]->u,s->t/P/S   I[s]|>s   s > t
        ------------------------------------------ simp-R-left-E
                    E/R,I[t]->u,s->t/P/S

        ##E->R# influence, version 2

        E,s[x]=t[x]/R/P/S   s[x] perp t[x]   y,z fresh
        ---------------------------------------------- branch-E
          E,s[y z]=t[y z],s[a]=t[a] for a in A/R/P/S

        #problems

                        E/R/P,l:_x:=_M.C[?]/S
        -------------------------------------------------- branch-P
        E/R/P,l:_x:=_M.C[? ?],l:x:=_M.C[a] for a in A+_x/S

        E/R/P,p/S   p false XXX
        ----------------------- prune-E
              E/R/P/S

        E/R,s->t/P,p[s]/S
        ----------------- simp-P
        E/R,s->t/P,p[t]/S

        E/R/P,l:???/S   l1,l2 fresh
        --------------------------- factor
        E/R/P,l:???,l':/S

        #solutions

        E/R/P,(x:=M |- s=s)/S
        --------------------- find
           E/R/P/S,l:(x:=M)

        E/R,s->t/P/S,l:(x:=C[s]. ...)
        ----------------------------- simp-S
        E/R,s->t/P/S,l:(x:=C[t]. ...)
      ###-
    Note that #subsume-E# is for efficiency purposes only

    Example: Consider a proof of #2(J x)y=J x y#:
      ###[
        2(J x)y
          <- J x(J x y)     ##2#-reduce
          -> J(J x x)y      ##J#-assoc
          -> J x y          ##J#-idem-1
      ###]
      This is found by the #E/R# part of state machine via
      ###[
        2 x y=x(x y),J x(J y z)=J(J x y)z,J x x=x/
        2 x y=x(x y)/J x(J y z)->J(J x y)z,J x x->x                   #orient
        2 x y=x(x y),2(J x)y=J(J x x)y/J x(J y z)->J(J x y)z,J x x->x #deduce
        2 x y=x(x y),2(J x)y=J x y/J x(J y z)->J(J x y)z,J x x->x     #simp-E
      ###]
      Note the use of the unfailing #deduce# rule;
      this equation would fail to be found by naive completion.

  Soundness and correctness. 
    LATER

  Fairness and completeness. 
    LATER
    We need to ensure fairness in
    * branching, in both branch-P and branch-E
    * 
    For example, we need to ensure that we branch evenly between a pair of
    holes
    ###[
      ? <| ? ?      <| ?(? ?)   <| ... 
        <| ? ? ?    <| ? ?(? ?)
        <| ...
    ###]
    A _branching_strategy_ chooses, for each term with holes, a hole in that
    term on which to branch.
    Each branching strategy and root term defines a #1+|A|#-ary tree, say the
    _refinement_tree_.
    Since branching can create more holes, we need to ensure every hole is
    eventually branched on.
    Thus we say a branching strategy is _fair_ iff every every hole in the
    refinement tree occurs only finitely often, or equivalently, eventually
    disappears at some depth in the tree.

    Here is a simple fair branching strategy
    Strategy: depth-then-head hole branching.
      Given: a term #M# with holes
      Choose: the shallowest hole in #M#'s app tree;
        to break ties, choose the left-most hole.
    Lem: depth-then-head is fair.
    Pf: There are at most finitely many holes at any level.
      The #i#'th hole appears for only #i-1#-many more levels in the refinement
      tree.
      []
    Example: Start with a single hole.  The branched hole is bracketed.
      ###[
        [?] <| [?]?
            <| ? ?[?]
            <| [?]?(? ?)
            <| ? ?[?](? ?)
            <| ? ?(? ?)([?]?)
            <| ? ?(? ?)(? ?[?])
            <| [?]?(? ?)(? ?(? ?))
            <| ...
      ###]
    Example: cycling in branch-and-simplify
      ###[
        [?] <| [?]? <| I ? -> [?]
        [?] <| [?]? <| ? ?[?] <| [?]?(? ?) <| K ?(? ?) -> [?]
      ###]
    Note: The finiteness in fairness is a bit arbitrary:
      so long as the head is a hole, the entire term is undefined.
      This happens for many infinite paths down the tree.
    Question: A better strategy might always branch on the head term, since it
      controls the rest of the term.
      Is there a fair way of doing so?


